// Code generated by eventmap-gen. DO NOT EDIT.

package persistence

import (
	"encoding/json"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/getpup/pupsourcing/es"

	v1 "github.com/getpup/pupsourcing/examples/eventmap-codegen/domain/user/events/v1"
	v2 "github.com/getpup/pupsourcing/examples/eventmap-codegen/domain/user/events/v2"
)

// Option is a functional option for configuring event metadata.
type Option func(*eventOptions)

type eventOptions struct {
	causationID   es.NullString
	correlationID es.NullString
	traceID       es.NullString
	metadata      []byte
}

// WithCausationID sets the causation ID for the event.
func WithCausationID(id string) Option {
	return func(o *eventOptions) {
		o.causationID = es.NullString{String: id, Valid: true}
	}
}

// WithCorrelationID sets the correlation ID for the event.
func WithCorrelationID(id string) Option {
	return func(o *eventOptions) {
		o.correlationID = es.NullString{String: id, Valid: true}
	}
}

// WithTraceID sets the trace ID for the event.
func WithTraceID(id string) Option {
	return func(o *eventOptions) {
		o.traceID = es.NullString{String: id, Valid: true}
	}
}

// WithMetadata sets custom metadata for the event.
func WithMetadata(metadata []byte) Option {
	return func(o *eventOptions) {
		o.metadata = metadata
	}
}

// EventTypeOf returns the event type string for a given domain event.
// The event type is the struct name without version information.
func EventTypeOf(e any) (string, error) {
	switch e.(type) {
	case v1.UserDeleted, *v1.UserDeleted:
		return "UserDeleted", nil
	case v1.UserEmailChanged, *v1.UserEmailChanged:
		return "UserEmailChanged", nil
	case v1.UserRegistered, *v1.UserRegistered:
		return "UserRegistered", nil
	case v2.UserRegistered, *v2.UserRegistered:
		return "UserRegistered", nil
	default:
		return "", fmt.Errorf("unknown event type: %T", e)
	}
}

// ToESEvents converts domain events to es.Event instances.
// Each domain event is marshaled to JSON and wrapped in an es.Event.
// The generic type T allows for type-safe event slices instead of []any.
func ToESEvents[T any](aggregateType string, aggregateID string, events []T, opts ...Option) ([]es.Event, error) {
	options := &eventOptions{}
	for _, opt := range opts {
		opt(options)
	}

	result := make([]es.Event, 0, len(events))

	for _, e := range events {
		eventType, err := EventTypeOf(e)
		if err != nil {
			return nil, err
		}

		payload, err := json.Marshal(e)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal event %s: %w", eventType, err)
		}

		metadata := options.metadata
		if metadata == nil {
			metadata = []byte("{}")
		}

		version := getEventVersion(e)

		event := es.Event{
			AggregateType: aggregateType,
			AggregateID:   aggregateID,
			EventType:     eventType,
			EventVersion:  version,
			EventID:       uuid.New(),
			Payload:       payload,
			Metadata:      metadata,
			CausationID:   options.causationID,
			CorrelationID: options.correlationID,
			TraceID:       options.traceID,
			CreatedAt:     time.Now(),
		}

		result = append(result, event)
	}

	return result, nil
}

// getEventVersion returns the version for a given domain event.
func getEventVersion(e any) int {
	switch e.(type) {
	case v1.UserDeleted, *v1.UserDeleted:
		return 1
	case v1.UserEmailChanged, *v1.UserEmailChanged:
		return 1
	case v1.UserRegistered, *v1.UserRegistered:
		return 1
	case v2.UserRegistered, *v2.UserRegistered:
		return 2
	default:
		return 1
	}
}

// FromESEvents converts persisted events back to domain events.
// The function uses generics to return a strongly-typed slice.
// T must be 'any' or a common interface implemented by all domain events.
func FromESEvents[T any](events []es.PersistedEvent) ([]T, error) {
	result := make([]T, 0, len(events))

	for i, pe := range events {
		domainEvent, err := fromESEvent(pe)
		if err != nil {
			return nil, fmt.Errorf("failed to convert event at index %d: %w", i, err)
		}

		// Type assertion
		typedEvent, ok := domainEvent.(T)
		if !ok {
			return nil, fmt.Errorf("event at index %d is not of expected type: got %T", i, domainEvent)
		}

		result = append(result, typedEvent)
	}

	return result, nil
}

// fromESEvent converts a single persisted event to a domain event.
func fromESEvent(pe es.PersistedEvent) (any, error) {
	switch pe.EventType {
	case "UserDeleted":
		switch pe.EventVersion {
		case 1:
			var e v1.UserDeleted
			if err := json.Unmarshal(pe.Payload, &e); err != nil {
				return nil, fmt.Errorf("failed to unmarshal UserDeleted v1: %w", err)
			}
			return e, nil
		default:
			return nil, fmt.Errorf("unknown version %d for event type UserDeleted", pe.EventVersion)
		}
	case "UserEmailChanged":
		switch pe.EventVersion {
		case 1:
			var e v1.UserEmailChanged
			if err := json.Unmarshal(pe.Payload, &e); err != nil {
				return nil, fmt.Errorf("failed to unmarshal UserEmailChanged v1: %w", err)
			}
			return e, nil
		default:
			return nil, fmt.Errorf("unknown version %d for event type UserEmailChanged", pe.EventVersion)
		}
	case "UserRegistered":
		switch pe.EventVersion {
		case 1:
			var e v1.UserRegistered
			if err := json.Unmarshal(pe.Payload, &e); err != nil {
				return nil, fmt.Errorf("failed to unmarshal UserRegistered v1: %w", err)
			}
			return e, nil
		case 2:
			var e v2.UserRegistered
			if err := json.Unmarshal(pe.Payload, &e); err != nil {
				return nil, fmt.Errorf("failed to unmarshal UserRegistered v2: %w", err)
			}
			return e, nil
		default:
			return nil, fmt.Errorf("unknown version %d for event type UserRegistered", pe.EventVersion)
		}
	default:
		return nil, fmt.Errorf("unknown event type: %s", pe.EventType)
	}
}

// ToUserDeletedV1 converts a domain event to an es.Event.
func ToUserDeletedV1(aggregateType string, aggregateID string, e v1.UserDeleted, opts ...Option) (es.Event, error) {
	options := &eventOptions{}
	for _, opt := range opts {
		opt(options)
	}

	payload, err := json.Marshal(e)
	if err != nil {
		return es.Event{}, fmt.Errorf("failed to marshal UserDeleted: %w", err)
	}

	metadata := options.metadata
	if metadata == nil {
		metadata = []byte("{}")
	}

	return es.Event{
		AggregateType: aggregateType,
		AggregateID:   aggregateID,
		EventType:     "UserDeleted",
		EventVersion:  1,
		EventID:       uuid.New(),
		Payload:       payload,
		Metadata:      metadata,
		CausationID:   options.causationID,
		CorrelationID: options.correlationID,
		TraceID:       options.traceID,
		CreatedAt:     time.Now(),
	}, nil
}

// FromUserDeletedV1 converts a persisted event to a domain event.
// Returns an error if the event type or version doesn't match.
func FromUserDeletedV1(pe es.PersistedEvent) (v1.UserDeleted, error) {
	if pe.EventType != "UserDeleted" {
		return v1.UserDeleted{}, fmt.Errorf("expected event type UserDeleted, got %s", pe.EventType)
	}
	if pe.EventVersion != 1 {
		return v1.UserDeleted{}, fmt.Errorf("expected event version 1, got %d", pe.EventVersion)
	}

	var e v1.UserDeleted
	if err := json.Unmarshal(pe.Payload, &e); err != nil {
		return v1.UserDeleted{}, fmt.Errorf("failed to unmarshal UserDeleted v1: %w", err)
	}

	return e, nil
}

// ToUserEmailChangedV1 converts a domain event to an es.Event.
func ToUserEmailChangedV1(aggregateType string, aggregateID string, e v1.UserEmailChanged, opts ...Option) (es.Event, error) {
	options := &eventOptions{}
	for _, opt := range opts {
		opt(options)
	}

	payload, err := json.Marshal(e)
	if err != nil {
		return es.Event{}, fmt.Errorf("failed to marshal UserEmailChanged: %w", err)
	}

	metadata := options.metadata
	if metadata == nil {
		metadata = []byte("{}")
	}

	return es.Event{
		AggregateType: aggregateType,
		AggregateID:   aggregateID,
		EventType:     "UserEmailChanged",
		EventVersion:  1,
		EventID:       uuid.New(),
		Payload:       payload,
		Metadata:      metadata,
		CausationID:   options.causationID,
		CorrelationID: options.correlationID,
		TraceID:       options.traceID,
		CreatedAt:     time.Now(),
	}, nil
}

// FromUserEmailChangedV1 converts a persisted event to a domain event.
// Returns an error if the event type or version doesn't match.
func FromUserEmailChangedV1(pe es.PersistedEvent) (v1.UserEmailChanged, error) {
	if pe.EventType != "UserEmailChanged" {
		return v1.UserEmailChanged{}, fmt.Errorf("expected event type UserEmailChanged, got %s", pe.EventType)
	}
	if pe.EventVersion != 1 {
		return v1.UserEmailChanged{}, fmt.Errorf("expected event version 1, got %d", pe.EventVersion)
	}

	var e v1.UserEmailChanged
	if err := json.Unmarshal(pe.Payload, &e); err != nil {
		return v1.UserEmailChanged{}, fmt.Errorf("failed to unmarshal UserEmailChanged v1: %w", err)
	}

	return e, nil
}

// ToUserRegisteredV1 converts a domain event to an es.Event.
func ToUserRegisteredV1(aggregateType string, aggregateID string, e v1.UserRegistered, opts ...Option) (es.Event, error) {
	options := &eventOptions{}
	for _, opt := range opts {
		opt(options)
	}

	payload, err := json.Marshal(e)
	if err != nil {
		return es.Event{}, fmt.Errorf("failed to marshal UserRegistered: %w", err)
	}

	metadata := options.metadata
	if metadata == nil {
		metadata = []byte("{}")
	}

	return es.Event{
		AggregateType: aggregateType,
		AggregateID:   aggregateID,
		EventType:     "UserRegistered",
		EventVersion:  1,
		EventID:       uuid.New(),
		Payload:       payload,
		Metadata:      metadata,
		CausationID:   options.causationID,
		CorrelationID: options.correlationID,
		TraceID:       options.traceID,
		CreatedAt:     time.Now(),
	}, nil
}

// FromUserRegisteredV1 converts a persisted event to a domain event.
// Returns an error if the event type or version doesn't match.
func FromUserRegisteredV1(pe es.PersistedEvent) (v1.UserRegistered, error) {
	if pe.EventType != "UserRegistered" {
		return v1.UserRegistered{}, fmt.Errorf("expected event type UserRegistered, got %s", pe.EventType)
	}
	if pe.EventVersion != 1 {
		return v1.UserRegistered{}, fmt.Errorf("expected event version 1, got %d", pe.EventVersion)
	}

	var e v1.UserRegistered
	if err := json.Unmarshal(pe.Payload, &e); err != nil {
		return v1.UserRegistered{}, fmt.Errorf("failed to unmarshal UserRegistered v1: %w", err)
	}

	return e, nil
}

// ToUserRegisteredV2 converts a domain event to an es.Event.
func ToUserRegisteredV2(aggregateType string, aggregateID string, e v2.UserRegistered, opts ...Option) (es.Event, error) {
	options := &eventOptions{}
	for _, opt := range opts {
		opt(options)
	}

	payload, err := json.Marshal(e)
	if err != nil {
		return es.Event{}, fmt.Errorf("failed to marshal UserRegistered: %w", err)
	}

	metadata := options.metadata
	if metadata == nil {
		metadata = []byte("{}")
	}

	return es.Event{
		AggregateType: aggregateType,
		AggregateID:   aggregateID,
		EventType:     "UserRegistered",
		EventVersion:  2,
		EventID:       uuid.New(),
		Payload:       payload,
		Metadata:      metadata,
		CausationID:   options.causationID,
		CorrelationID: options.correlationID,
		TraceID:       options.traceID,
		CreatedAt:     time.Now(),
	}, nil
}

// FromUserRegisteredV2 converts a persisted event to a domain event.
// Returns an error if the event type or version doesn't match.
func FromUserRegisteredV2(pe es.PersistedEvent) (v2.UserRegistered, error) {
	if pe.EventType != "UserRegistered" {
		return v2.UserRegistered{}, fmt.Errorf("expected event type UserRegistered, got %s", pe.EventType)
	}
	if pe.EventVersion != 2 {
		return v2.UserRegistered{}, fmt.Errorf("expected event version 2, got %d", pe.EventVersion)
	}

	var e v2.UserRegistered
	if err := json.Unmarshal(pe.Payload, &e); err != nil {
		return v2.UserRegistered{}, fmt.Errorf("failed to unmarshal UserRegistered v2: %w", err)
	}

	return e, nil
}

