// Code generated by eventmap-gen. DO NOT EDIT.

package persistence

import (
	"testing"
	"time"

	"github.com/google/uuid"
	"github.com/getpup/pupsourcing/es"

	v1 "github.com/getpup/pupsourcing/examples/eventmap-codegen/domain/user/events/v1"
	v2 "github.com/getpup/pupsourcing/examples/eventmap-codegen/domain/user/events/v2"
)

// TestEventTypeOf tests the EventTypeOf function.
func TestEventTypeOf(t *testing.T) {
	tests := []struct {
		name      string
		event     any
		wantType  string
		wantError bool
	}{
		{
			name:      "UserDeletedV1",
			event:     v1.UserDeleted{},
			wantType:  "UserDeleted",
			wantError: false,
		},
		{
			name:      "UserDeletedV1Pointer",
			event:     &v1.UserDeleted{},
			wantType:  "UserDeleted",
			wantError: false,
		},
		{
			name:      "UserEmailChangedV1",
			event:     v1.UserEmailChanged{},
			wantType:  "UserEmailChanged",
			wantError: false,
		},
		{
			name:      "UserEmailChangedV1Pointer",
			event:     &v1.UserEmailChanged{},
			wantType:  "UserEmailChanged",
			wantError: false,
		},
		{
			name:      "UserRegisteredV1",
			event:     v1.UserRegistered{},
			wantType:  "UserRegistered",
			wantError: false,
		},
		{
			name:      "UserRegisteredV1Pointer",
			event:     &v1.UserRegistered{},
			wantType:  "UserRegistered",
			wantError: false,
		},
		{
			name:      "UserRegisteredV2",
			event:     v2.UserRegistered{},
			wantType:  "UserRegistered",
			wantError: false,
		},
		{
			name:      "UserRegisteredV2Pointer",
			event:     &v2.UserRegistered{},
			wantType:  "UserRegistered",
			wantError: false,
		},
		{
			name:      "UnknownType",
			event:     struct{}{},
			wantType:  "",
			wantError: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			gotType, err := EventTypeOf(tt.event)
			if (err != nil) != tt.wantError {
				t.Errorf("EventTypeOf() error = %v, wantError %v", err, tt.wantError)
				return
			}
			if gotType != tt.wantType {
				t.Errorf("EventTypeOf() = %v, want %v", gotType, tt.wantType)
			}
		})
	}
}

// TestToESEvents tests the ToESEvents function with generics.
func TestToESEvents(t *testing.T) {
	boundedContext := "TestContext"
	aggregateType := "TestAggregate"
	aggregateID := uuid.New().String()

	// Create a domain event
	domainEvent := v1.UserDeleted{}

	// Test with slice of specific type (not []any)
	events := []v1.UserDeleted{domainEvent}
	
	esEvents, err := ToESEvents(boundedContext, aggregateType, aggregateID, events)
	if err != nil {
		t.Fatalf("ToESEvents() failed: %v", err)
	}

	if len(esEvents) != 1 {
		t.Fatalf("Expected 1 event, got %d", len(esEvents))
	}

	esEvent := esEvents[0]

	// Verify event properties
	if esEvent.BoundedContext != boundedContext {
		t.Errorf("BoundedContext = %s, want %s", esEvent.BoundedContext, boundedContext)
	}
	if esEvent.AggregateType != aggregateType {
		t.Errorf("AggregateType = %s, want %s", esEvent.AggregateType, aggregateType)
	}
	if esEvent.AggregateID != aggregateID {
		t.Errorf("AggregateID = %s, want %s", esEvent.AggregateID, aggregateID)
	}
	if esEvent.EventType != "UserDeleted" {
		t.Errorf("EventType = %s, want %s", esEvent.EventType, "UserDeleted")
	}
	if esEvent.EventVersion != 1 {
		t.Errorf("EventVersion = %d, want %d", esEvent.EventVersion, 1)
	}
	if esEvent.EventID == uuid.Nil {
		t.Error("EventID should not be nil")
	}
	if esEvent.CreatedAt.IsZero() {
		t.Error("CreatedAt should not be zero")
	}
}

// TestFromESEvents tests the FromESEvents function.
func TestFromESEvents(t *testing.T) {
	// Create a persisted event
	persistedEvent := es.PersistedEvent{
		CreatedAt:        time.Now(),
		AggregateType:    "TestAggregate",
		EventType:        "UserDeleted",
		AggregateID:      uuid.New().String(),
		Payload:          []byte("{}"),
		Metadata:         []byte("{}"),
		GlobalPosition:   1,
		AggregateVersion: 1,
		EventVersion:     1,
		EventID:          uuid.New(),
	}

	// Convert to domain events
	domainEvents, err := FromESEvents[any]([]es.PersistedEvent{persistedEvent})
	if err != nil {
		t.Fatalf("FromESEvents() failed: %v", err)
	}

	if len(domainEvents) != 1 {
		t.Fatalf("Expected 1 domain event, got %d", len(domainEvents))
	}

	// Verify type
	_, ok := domainEvents[0].(v1.UserDeleted)
	if !ok {
		t.Errorf("Expected %T, got %T", v1.UserDeleted{}, domainEvents[0])
	}
}

// TestOptions tests the Options pattern.
func TestOptions(t *testing.T) {
	boundedContext := "TestContext"
	aggregateType := "TestAggregate"
	aggregateID := uuid.New().String()

	domainEvent := v1.UserDeleted{}
	
	// Use options
	esEvents, err := ToESEvents(
		boundedContext,
		aggregateType,
		aggregateID,
		[]v1.UserDeleted{domainEvent},
		WithCausationID("causation-123"),
		WithCorrelationID("correlation-456"),
		WithTraceID("trace-789"),
		WithMetadata([]byte("{\"key\":\"value\"}")),
	)
	if err != nil {
		t.Fatalf("ToESEvents() failed: %v", err)
	}

	if len(esEvents) != 1 {
		t.Fatalf("Expected 1 event, got %d", len(esEvents))
	}

	esEvent := esEvents[0]

	// Verify options were applied
	if !esEvent.CausationID.Valid || esEvent.CausationID.String != "causation-123" {
		t.Errorf("CausationID not set correctly: got %v", esEvent.CausationID)
	}
	if !esEvent.CorrelationID.Valid || esEvent.CorrelationID.String != "correlation-456" {
		t.Errorf("CorrelationID not set correctly: got %v", esEvent.CorrelationID)
	}
	if !esEvent.TraceID.Valid || esEvent.TraceID.String != "trace-789" {
		t.Errorf("TraceID not set correctly: got %v", esEvent.TraceID)
	}
	if string(esEvent.Metadata) != "{\"key\":\"value\"}" {
		t.Errorf("Metadata not set correctly: got %s", string(esEvent.Metadata))
	}
}

// TestTypeHelpers tests type-specific helper functions.
func TestTypeHelpers(t *testing.T) {
	boundedContext := "TestContext"
	aggregateType := "TestAggregate"
	aggregateID := uuid.New().String()

	domainEvent := v1.UserDeleted{}

	// Test To helper
	esEvent, err := ToUserDeletedV1(boundedContext, aggregateType, aggregateID, domainEvent)
	if err != nil {
		t.Fatalf("ToUserDeletedV1() failed: %v", err)
	}

	if esEvent.EventType != "UserDeleted" {
		t.Errorf("EventType = %s, want %s", esEvent.EventType, "UserDeleted")
	}
	if esEvent.EventVersion != 1 {
		t.Errorf("EventVersion = %d, want %d", esEvent.EventVersion, 1)
	}

	// Convert to persisted event
	persistedEvent := es.PersistedEvent{
		CreatedAt:        esEvent.CreatedAt,
		BoundedContext:   esEvent.BoundedContext,
		AggregateType:    esEvent.AggregateType,
		EventType:        esEvent.EventType,
		AggregateID:      esEvent.AggregateID,
		Payload:          esEvent.Payload,
		Metadata:         esEvent.Metadata,
		CausationID:      esEvent.CausationID,
		CorrelationID:    esEvent.CorrelationID,
		TraceID:          esEvent.TraceID,
		GlobalPosition:   1,
		AggregateVersion: 1,
		EventVersion:     esEvent.EventVersion,
		EventID:          esEvent.EventID,
	}

	// Test From helper
	restored, err := FromUserDeletedV1(persistedEvent)
	if err != nil {
		t.Fatalf("FromUserDeletedV1() failed: %v", err)
	}

	// Verify type
	_ = restored // Type assertion happens in function call
}

// TestErrorCases tests error handling.
func TestErrorCases(t *testing.T) {
	t.Run("UnknownEventType", func(t *testing.T) {
		persistedEvent := es.PersistedEvent{
			CreatedAt:        time.Now(),
			AggregateType:    "TestAggregate",
			EventType:        "UnknownEvent",
			AggregateID:      uuid.New().String(),
			Payload:          []byte("{}"),
			Metadata:         []byte("{}"),
			GlobalPosition:   1,
			AggregateVersion: 1,
			EventVersion:     1,
			EventID:          uuid.New(),
		}

		_, err := FromESEvents[any]([]es.PersistedEvent{persistedEvent})
		if err == nil {
			t.Error("Expected error for unknown event type")
		}
	})

	t.Run("InvalidJSON", func(t *testing.T) {
		persistedEvent := es.PersistedEvent{
			CreatedAt:        time.Now(),
			AggregateType:    "TestAggregate",
			EventType:        "UserDeleted",
			AggregateID:      uuid.New().String(),
			Payload:          []byte("invalid json"),
			Metadata:         []byte("{}"),
			GlobalPosition:   1,
			AggregateVersion: 1,
			EventVersion:     1,
			EventID:          uuid.New(),
		}

		_, err := FromESEvents[any]([]es.PersistedEvent{persistedEvent})
		if err == nil {
			t.Error("Expected error for invalid JSON")
		}
	})
}